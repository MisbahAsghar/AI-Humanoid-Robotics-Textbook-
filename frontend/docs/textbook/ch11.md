---
title: "Chapter 11: Navigation and Manipulation"
sidebar_position: 11
---
# Chapter 11: Navigation and Manipulation

**Part**: 6 - Capstone Integration
**Estimated Reading Time**: 50-60 minutes
**Estimated Practice Time**: 8-10 hours (including Nav2/MoveIt configuration)

---

## Learning Objectives

**Conceptual Understanding**:
- Explain path planning algorithms (A*, RRT, DWA)
- Understand costmaps for obstacle representation
- Describe inverse kinematics (IK) and its role in manipulation
- Explain grasp planning strategies (parallel-jaw, power grasp, precision grasp)
- Understand force control for compliant manipulation
- Compare navigation approaches (global vs local planning)

**Practical Skills**:
- Configure Nav2 for autonomous navigation
- Implement waypoint-following missions
- Set up MoveIt for arm motion planning
- Solve inverse kinematics for target poses
- Implement pick-and-place pipeline
- Integrate Nav2 + MoveIt for mobile manipulation
- Debug navigation failures (stuck robot, oscillation, collision)

---

## Prerequisites

- Chapters 3-4 (ROS 2, URDF)
- Chapter 5 (Gazebo simulation)
- Chapter 9 (VLA, action primitives)

---

## Part 1: Theory (40%)

### 1.1 Path Planning Algorithms

**A* (A-Star)**: Graph search with heuristic
- **Cost**: $f(n) = g(n) + h(n)$ (actual cost + heuristic to goal)
- **Optimal**: If heuristic admissible (never overestimates)
- **Use**: Global planning on known maps

**RRT (Rapidly-exploring Random Tree)**:
- Samples random configurations, connects nearest neighbors
- **Probabilistically complete**: Finds solution if exists (given infinite time)
- **Use**: High-dimensional spaces (7-DOF arms), unknown environments

**DWA (Dynamic Window Approach)**:
- Samples velocity commands $(v, \omega)$ in robot's dynamic constraints
- **Real-time**: less than 10 ms per cycle
- **Use**: Local obstacle avoidance, reactive navigation

---

### 1.2 Inverse Kinematics

**Forward Kinematics (FK)**: Joint angles → end-effector pose

$$
\mathbf{p}_{\text{ee}} = f(\theta_1, \theta_2, \ldots, \theta_n)
$$

**Inverse Kinematics (IK)**: End-effector pose → joint angles

$$
[\theta_1, \theta_2, \ldots, \theta_n] = f^{-1}(\mathbf{p}_{\text{ee}})
$$

**Challenge**: Multiple solutions (redundancy) or no solution (unreachable pose)

**Methods**:
- **Analytical**: Closed-form solution (fast, limited to specific geometries)
- **Numerical** (Jacobian): Iterative optimization (slower, works for any robot)
- **Sampling** (RRT): Random search in joint space

**MoveIt** uses numerical IK with KDL (Kinematics Dynamics Library) solver.

---

### 1.3 Grasp Planning

**Grasp Types**:
1. **Parallel-jaw**: Two-finger gripper (cups, boxes)
2. **Power grasp**: Enveloping object (hammer, bottle)
3. **Precision grasp**: Fingertip control (pen, small objects)

**Grasp Quality Metrics**:
- **Force closure**: Can resist external wrenches
- **Form closure**: Geometric constraints prevent motion

**Grasp Planning**:
- **GraspNet**: Neural network predicts grasp poses from point cloud
- **Contact-GraspNet**: 6-DOF grasps with contact points

---

## Part 2: Practice (60%)

### 2.1 Nav2 Configuration

Create `nav2_params.yaml`:

```yaml
bt_navigator:
  ros__parameters:
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odom
    default_bt_xml_filename: navigate_w_replanning.xml

controller_server:
  ros__parameters:
    controller_frequency: 20.0
    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      min_vel_x: 0.0
      max_vel_x: 0.5
      min_vel_theta: 0.0
      max_vel_theta: 1.0

planner_server:
  ros__parameters:
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
```

**Launch Nav2**:
```bash
ros2 launch nav2_bringup navigation_launch.py params_file:=nav2_params.yaml
```

---

### 2.2 MoveIt Pick-and-Place

Create `pick_and_place.py`:

```python
#!/usr/bin/env python3
"""
Pick-and-Place with MoveIt
Chapter 11: Navigation and Manipulation
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Pose
import moveit_commander


class PickAndPlace(Node):
    def __init__(self):
        super().__init__('pick_and_place')

        # Initialize MoveIt
        moveit_commander.roscpp_initialize([])
        self.robot = moveit_commander.RobotCommander()
        self.arm = moveit_commander.MoveGroupCommander("arm")
        self.gripper = moveit_commander.MoveGroupCommander("gripper")

        # Set planning parameters
        self.arm.set_planning_time(5.0)
        self.arm.set_num_planning_attempts(10)
        self.arm.set_goal_tolerance(0.01)

        self.get_logger().info('MoveIt initialized')

    def pick(self, object_pose: Pose) -> bool:
        """Execute pick primitive."""
        # Approach pose (10cm above)
        approach = object_pose
        approach.position.z += 0.1

        self.arm.set_pose_target(approach)
        success = self.arm.go(wait=True)
        if not success:
            return False

        # Open gripper
        self.gripper.set_named_target("open")
        self.gripper.go(wait=True)

        # Move to grasp
        self.arm.set_pose_target(object_pose)
        self.arm.go(wait=True)

        # Close gripper
        self.gripper.set_named_target("close")
        self.gripper.go(wait=True)

        # Lift
        lift = object_pose
        lift.position.z += 0.1
        self.arm.set_pose_target(lift)
        self.arm.go(wait=True)

        return True

    def place(self, target_pose: Pose) -> bool:
        """Execute place primitive."""
        self.arm.set_pose_target(target_pose)
        self.arm.go(wait=True)

        self.gripper.set_named_target("open")
        self.gripper.go(wait=True)

        # Retract
        retract = target_pose
        retract.position.z += 0.1
        self.arm.set_pose_target(retract)
        self.arm.go(wait=True)

        return True


def main():
    rclpy.init()
    node = PickAndPlace()

    # Example: Pick at (0.5, 0.2, 0.8), place at (0.3, -0.3, 0.9)
    pick_pose = Pose()
    pick_pose.position.x, pick_pose.position.y, pick_pose.position.z = 0.5, 0.2, 0.8

    place_pose = Pose()
    place_pose.position.x, place_pose.position.y, place_pose.position.z = 0.3, -0.3, 0.9

    success = node.pick(pick_pose)
    if success:
        node.place(place_pose)

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## Review Questions

**Q1**: Explain difference between global and local planning in Nav2.

**Q2**: What is IK? Why can there be multiple solutions for same end-effector pose?

**Q3**: Name 3 grasp types and their use cases.

**Q4**: List 3 common navigation failures and how to debug them.

**Q5**: Why is force control important for manipulation?

---

## Exercises

**Ex1**: Configure Nav2 for warehouse navigation
**Ex2**: Implement IK solver for 7-DOF arm
**Ex3**: Pick-and-place pipeline with object detection

---

## Key Takeaways

1. Nav2 architecture (AMCL, costmaps, planners, controllers)
2. Path planning: A* (global), DWA (local), RRT (high-dim)
3. IK solves end-effector pose → joint angles (multiple solutions possible)
4. MoveIt for motion planning with collision avoidance
5. Grasp planning: parallel-jaw, power, precision grasps
6. Force control for compliant manipulation
7. Mobile manipulation integrates Nav2 + MoveIt
8. Debugging: costmap visualization, plan inspection
9. Safety: workspace limits, collision checking, force thresholds
10. Real-world deployment: calibration, error recovery, fallback behaviors

---

**Last Updated**: 2025-12-23
